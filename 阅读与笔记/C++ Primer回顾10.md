<h2>拷贝控制</h2>

编译器会为我们合成一个拷贝构造函数，无论我们是否定义了其他构造函数

拷贝构造函数必须参数是引用：因为自身的参数是非引用类型，为了调用它，必须拷贝其实参，而为了拷贝实参，又要调用拷贝构造函数···出现了无限递归导致错误

赋值运算符通常应该返回一个指向其左侧运算对象的引用（否则无法进行从右向左连续赋值）

```cpp
class Foo{
public:
    Foo &operator=(const Foo &);
    //...
};
```

由编译器生成的“合成拷贝构造函数”与“合成拷贝赋值运算符”都是用来完成拷贝，**部分情况（类中有数据成员不能默认构造、拷贝、赋值(比如有const)或销毁）下是阻止拷贝或赋值该类型对象**；**C++11**：我们也可以自己写这样的函数来进行阻止：`=delete`通知编译器，我们不希望定义与使用这些成员，且必须出现在函数第一次声明的时候（我们不能删除析构函数，如果类中定义了这样的析构函数，编译器将不允许我们将该类实例化）：

```cpp
struct NoCopy{
    NoCopy() = default;
    //新标准之前是把这两个函数放到private中进行阻止，并且只声明，不定义：
    NoCopy(const NoCopy&) = delete;//阻止拷贝
    NoCopy &operator=(const NoCopy&) = delete;//阻止赋值
    
    ~NoCopy() = default;
    //...
};
```

构造函数：构造函数初始化对象的非static成员<br>
析构函数：析构函数释放对象使用的资源，销毁对象的非static数据成员，不接受参数；析构函数自身并不直接销毁成员，成员是析构函数体之后的隐含的析构阶段被销毁；当没有定义析构函数时，编译器会为它生成“合成析构函数”，函数体为空，成员在这个空函数体执行完后逐个销毁；当类中分配动态内存时，需要自己定义一个析构函数，在函数体中对构造函数分配的内存进行delete处理

三/五法则：当类需要一个析构函数时，那么它同时也需要一个拷贝构造函数与拷贝赋值运算符，因为编译器提供的往往是基于bit的全拷贝；当需要拷贝操作的类也需要赋值操作，反之亦然，但不一定需要析构函数

```cpp
class HasPtr{
public:
    HasPtr(const string &s = string()):ps(new string(s)),i(0){}
    ~HasPtr(){delete ps;}
    //没有定义拷贝构造函数与拷贝赋值运算符，将使用编译器默认提供的...
private:
    string *ps;
    int i;
};

//上面的类定义因为没有遵循三/五法则导致错误
HasPtr f(HasPtr hp)//值传递，拷贝
{
    HasPtr ret = hp;//拷贝给定的HasPtr（基于bit的拷贝，指针指向同一块内存）
    return ret;//ret和hp都被销毁
}

HasPtr p("test");
f(p);//f结束时，p.ps指向的内存已经被释放
HasPtr q(p);//现在p与q都指向无效内存！
```

